// This file is @generated by prost-build.
/// / Represents a complete feed schema to be performed by a Switchboard oracle.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OracleFeed {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// / A list of jobs to be performed by the oracle.
    #[prost(message, repeated, tag = "2")]
    pub jobs: ::prost::alloc::vec::Vec<OracleJob>,
    /// / The number of oracles to sample before returning a result.
    #[prost(uint32, optional, tag = "3")]
    pub min_oracle_samples: ::core::option::Option<u32>,
    /// / The minimum number of jobs required to succeed in order to produce a result.
    #[prost(uint32, optional, tag = "4")]
    pub min_job_responses: ::core::option::Option<u32>,
    /// / Maximum allowed percentage deviation between job responses.
    #[prost(uint64, optional, tag = "5")]
    pub max_job_range_pct: ::core::option::Option<u64>,
}
/// / Represnts a list of tasks to be performed by a Switchboard oracle.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OracleJob {
    /// / The chain of tasks to perform for this OracleJob.
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<oracle_job::Task>,
    /// / The weight to assign to this job's result when aggregating multiple job results. A higher
    /// / weight means this job's result will have more influence on the final aggregated value. This
    /// / value must be greater than or equal to 0.
    #[prost(uint32, optional, tag = "2", default = "1")]
    pub weight: ::core::option::Option<u32>,
}
/// Nested message and enum types in `OracleJob`.
pub mod oracle_job {
    ///
    /// The adapter will report the text body of a successful HTTP request to the
    /// specified url, or return an error if the response status code is greater
    /// than or equal to 400.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: String representation of the http response.
    ///
    /// _**Example**_: Basic HttpTask
    ///
    /// ```json
    /// {"httpTask": {"url": "<https://mywebsite.org/path"}> }
    /// ```
    ///
    /// _**Example**_: HttpTask example with headers
    ///
    /// ```json
    /// { "httpTask": { "url": "<https://mywebsite.org/path",> "method": "METHOD_POST", "headers": \[ { "key": "MY_HEADER_KEY", "value": "MY_HEADER_VALUE" } \], "body": "{\"MY_BODY_KEY\":\"MY_BODY_VALUE\"}" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HttpTask {
        /// / A string containing the URL to direct this HTTP request to.
        #[prost(string, optional, tag = "1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        /// / The type of HTTP request to make.
        #[prost(enumeration = "http_task::Method", optional, tag = "2")]
        pub method: ::core::option::Option<i32>,
        /// / A list of headers to add to this HttpTask.
        #[prost(message, repeated, tag = "3")]
        pub headers: ::prost::alloc::vec::Vec<http_task::Header>,
        /// / A stringified body (if any) to add to this HttpTask.
        #[prost(string, optional, tag = "4")]
        pub body: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `HttpTask`.
    pub mod http_task {
        /// / An object that represents a header to add to an HTTP request.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Header {
            /// / A header key such as `Authorization` or `Content-Type`
            #[prost(string, optional, tag = "1")]
            pub key: ::core::option::Option<::prost::alloc::string::String>,
            /// / A value for the given header key like `Basic MYAUTHKEY` or `application/json`
            #[prost(string, optional, tag = "2")]
            pub value: ::core::option::Option<::prost::alloc::string::String>,
        }
        /// / An enumeration representing the types of HTTP requests available to make.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Method {
            /// / Unset HTTP method will default to METHOD_GET
            Unkown = 0,
            /// / Perform an HTTP 'GET' request.
            Get = 1,
            /// / Perform an HTTP 'POST' request.
            Post = 2,
        }
        impl Method {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unkown => "METHOD_UNKOWN",
                    Self::Get => "METHOD_GET",
                    Self::Post => "METHOD_POST",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "METHOD_UNKOWN" => Some(Self::Unkown),
                    "METHOD_GET" => Some(Self::Get),
                    "METHOD_POST" => Some(Self::Post),
                    _ => None,
                }
            }
        }
    }
    ///
    /// The adapter walks the path specified and returns the value found at that result. If returning
    /// JSON data from the HttpGet or HttpPost adapters, you must use this adapter to parse the response.
    ///
    /// _**Input**_: String representation of a JSON object.
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Parses the price field from a JSON object
    ///
    /// ```json
    /// {"jsonParse": {"path": "$.price"} }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JsonParseTask {
        /// / JSONPath formatted path to the element. <https://t.ly/uLtw>
        /// / <https://www.npmjs.com/package/jsonpath-plus>
        #[prost(string, optional, tag = "1")]
        pub path: ::core::option::Option<::prost::alloc::string::String>,
        /// / The technique that will be used to aggregate the results if walking the specified path returns multiple numerical results.
        #[prost(enumeration = "json_parse_task::AggregationMethod", optional, tag = "2")]
        pub aggregation_method: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `JsonParseTask`.
    pub mod json_parse_task {
        /// / The methods of combining a list of numerical results.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AggregationMethod {
            None = 0,
            /// / Grab the minimum value of the results.
            Min = 1,
            /// / Grab the maximum value of the results.
            Max = 2,
            /// / Sum up all of the results.
            Sum = 3,
            /// / Average all of the results.
            Mean = 4,
            /// / Grab the median of the results.
            Median = 5,
        }
        impl AggregationMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Min => "MIN",
                    Self::Max => "MAX",
                    Self::Sum => "SUM",
                    Self::Mean => "MEAN",
                    Self::Median => "MEDIAN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "MIN" => Some(Self::Min),
                    "MAX" => Some(Self::Max),
                    "SUM" => Some(Self::Sum),
                    "MEAN" => Some(Self::Mean),
                    "MEDIAN" => Some(Self::Median),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Returns the median (middle) of all the results returned by the provided subtasks and subjobs. Nested tasks must return a Number.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the median numerical result of 3 tasks.
    ///
    /// ```json
    /// {"medianTask": {"tasks": \[{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}\]}}
    /// ```
    ///
    /// _**Example**_: Returns the median numerical result of 3 jobs.
    ///
    /// ```json
    /// {"medianTask": {"jobs": \[{"tasks": [{"httpTask": {"url": "<https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": \[{"httpTask": {"url": "<https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": [{"httpTask": {"url": "<https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask":> {"path": "$[0][7]"}}]}]}}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MedianTask {
        /// / A list of subtasks to process and produce a list of result values.
        #[prost(message, repeated, tag = "1")]
        pub tasks: ::prost::alloc::vec::Vec<Task>,
        /// / A list of subjobs to process and produce a list of result values.
        #[prost(message, repeated, tag = "2")]
        pub jobs: ::prost::alloc::vec::Vec<super::OracleJob>,
        /// / The minimum number of values before a successful median can be yielded.
        #[prost(int32, optional, tag = "3")]
        pub min_successful_required: ::core::option::Option<i32>,
        /// / The maximum range between the minimum and maximum values before a successful median can be yielded.
        #[prost(string, optional, tag = "4")]
        pub max_range_percent: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Returns the mean (average) of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the mean numerical result of 3 tasks.
    ///
    /// ```json
    /// {"meanTask": {"tasks": \[{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}\]}}
    /// ```
    ///
    /// _**Example**_: Returns the mean numerical result of 3 jobs.
    ///
    /// ```json
    /// {"meanTask": {"jobs": \[{"tasks": [{"httpTask": {"url": "<https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": \[{"httpTask": {"url": "<https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": [{"httpTask": {"url": "<https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask":> {"path": "$[0][7]"}}]}]}}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MeanTask {
        /// / A list of subtasks to process and produce a list of result values.
        #[prost(message, repeated, tag = "1")]
        pub tasks: ::prost::alloc::vec::Vec<Task>,
        /// / A list of subjobs to process and produce a list of result values.
        #[prost(message, repeated, tag = "2")]
        pub jobs: ::prost::alloc::vec::Vec<super::OracleJob>,
    }
    ///
    /// Returns the maximum value of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the maximum numerical result from 3 tasks.
    ///
    /// ```json
    /// {"maxTask": {"tasks": \[{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}\]}}
    /// ```
    ///
    /// _**Example**_: Returns the maximum numerical result from 3 jobs.
    ///
    /// ```json
    /// {"maxTask": {"jobs": \[{"tasks": [{"httpTask": {"url": "<https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": \[{"httpTask": {"url": "<https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": [{"httpTask": {"url": "<https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask":> {"path": "$[0][7]"}}]}]}}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MaxTask {
        /// / A list of subtasks to process and produce a list of result values.
        #[prost(message, repeated, tag = "1")]
        pub tasks: ::prost::alloc::vec::Vec<Task>,
        /// / A list of subjobs to process and produce a list of result values.
        #[prost(message, repeated, tag = "2")]
        pub jobs: ::prost::alloc::vec::Vec<super::OracleJob>,
    }
    ///
    /// Returns the minimum value of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the minimum numerical result from 3 tasks.
    ///
    /// ```json
    /// {"minTask": {"tasks": \[{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}\]}}
    /// ```
    ///
    /// _**Example**_: Returns the minimum numerical result from 3 jobs.
    ///
    /// ```json
    /// {"minTask": {"jobs": \[{"tasks": [{"httpTask": {"url": "<https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": \[{"httpTask": {"url": "<https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask":> {"path": "$.price"}}\]},{"tasks": [{"httpTask": {"url": "<https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask":> {"path": "$[0][7]"}}]}]}}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MinTask {
        /// / A list of subtasks to process and produce a list of result values.
        #[prost(message, repeated, tag = "1")]
        pub tasks: ::prost::alloc::vec::Vec<Task>,
        /// / A list of subjobs to process and produce a list of result values.
        #[prost(message, repeated, tag = "2")]
        pub jobs: ::prost::alloc::vec::Vec<super::OracleJob>,
    }
    ///
    /// Returns a specified value.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the value 10
    ///
    /// ```json
    /// {"valueTask": {"value": 10} }
    /// ```
    ///
    /// _**Example**_: Returns the currentRound result of an aggregator
    ///
    /// ```json
    /// {"valueTask": {"aggregatorPubkey": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"} }
    /// ```
    ///
    /// _**Example**_: Returns the value stored in a CacheTask variable
    ///
    /// ```json
    /// {"valueTask": {"big": "${ONE}"} }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValueTask {
        #[prost(oneof = "value_task::Value", tags = "1, 2, 3, 4, 5")]
        pub value: ::core::option::Option<value_task::Value>,
    }
    /// Nested message and enum types in `ValueTask`.
    pub mod value_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            /// / The value that will be returned from this task.
            #[prost(double, tag = "1")]
            Value(f64),
            /// / Specifies an aggregatorr to pull the value of.
            #[prost(string, tag = "2")]
            AggregatorPubkey(::prost::alloc::string::String),
            /// / A stringified big.js. `Accepts variable expansion syntax.`
            #[prost(string, tag = "3")]
            Big(::prost::alloc::string::String),
            /// / A stringified hex number (0x prefix is optional).
            #[prost(string, tag = "4")]
            Hex(::prost::alloc::string::String),
            /// A utf8 string.
            #[prost(string, tag = "5")]
            Utf8(::prost::alloc::string::String),
        }
    }
    ///
    /// Opens and maintains a websocket for light speed data retrieval.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: String representation of the websocket subscription message.
    ///
    /// _**Example**_: Opens a coinbase websocket
    ///
    /// ```json
    /// { "websocketTask": { "url": "wss://ws-feed.pro.coinbase.com", "subscription": "{\"type\":\"subscribe\",\"product_ids\":\[\"BTC-USD\"\],\"channels\":\[\"ticker\",{\"name\":\"ticker\",\"product_ids\":[\"BTC-USD\"\]}]}", "maxDataAgeSeconds": 15, "filter": "$\[?(@.type == 'ticker' && @.product_id == 'BTC-USD')\]" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebsocketTask {
        /// / The websocket url.
        #[prost(string, optional, tag = "1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        /// / The websocket message to notify of a new subscription.
        #[prost(string, optional, tag = "2")]
        pub subscription: ::core::option::Option<::prost::alloc::string::String>,
        /// / Minimum amount of time required between when the horses are taking out.
        #[prost(int32, optional, tag = "3")]
        pub max_data_age_seconds: ::core::option::Option<i32>,
        /// / Incoming message JSONPath filter.
        /// / Example: "$\[?(@.channel == 'ticker' && @.market == 'BTC/USD')\]"
        #[prost(string, optional, tag = "4")]
        pub filter: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// This task will run the `attempt` on the subtasks in an effort to produce a valid numerical result. If `attempt`. fails to produce an acceptable result, `on_failure` subtasks will be run instead.
    ///
    /// _**Input**_: The current running numerical result output from a task.
    ///
    /// _**Returns**_: A numerical result, else run `on_failure` subtasks.
    ///
    /// _**Example**_: Returns the numerical result from the conditionalTask's subtasks, else `on_failure` returns the numerical result from its subtasks.
    ///
    /// ```json
    /// {"conditionalTask":{"attempt":\[{"tasks":[{"jupiterSwapTask":{"inTokenAddress":"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v","outTokenAddress":"DUALa4FC2yREwZ59PHeu1un4wis36vHRv5hWVBmzykCJ"}}\]}],"onFailure":\[{"lpExchangeRateTask":{"orcaPoolAddress":"7yJ4gMRJhEoCR48aPE3EAWRmCoygakik81ZS1sajaTnE"}}\]}}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConditionalTask {
        /// / A list of subtasks to process in an attempt to produce a valid numerical result.
        #[prost(message, repeated, tag = "1")]
        pub attempt: ::prost::alloc::vec::Vec<Task>,
        /// / A list of subtasks that will be run if `attempt` subtasks are unable to produce an acceptable
        /// / result.
        #[prost(message, repeated, tag = "2")]
        pub on_failure: ::prost::alloc::vec::Vec<Task>,
    }
    ///
    /// This task will divide a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
    ///
    /// _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the numerical result by dividing by a job of subtasks.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"divideTask":{"job":{"tasks":[{"valueTask":{"value":10}}\]}}}]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by dividing by an aggregator.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"divideTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}\]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by dividing by a big.
    ///
    /// ```json
    /// {"tasks":\[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}\]}}]}},{"valueTask":{"value":100}},{"divideTask":{"big":"${TEN}"}}]}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DivideTask {
        #[prost(oneof = "divide_task::Denominator", tags = "1, 2, 3, 4")]
        pub denominator: ::core::option::Option<divide_task::Denominator>,
    }
    /// Nested message and enum types in `DivideTask`.
    pub mod divide_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Denominator {
            /// / Specifies a basic scalar denominator to divide by.
            #[prost(double, tag = "1")]
            Scalar(f64),
            /// / Specifies another aggregator resut to divide by.
            #[prost(string, tag = "2")]
            AggregatorPubkey(::prost::alloc::string::String),
            /// / A job whose result is computed before dividing our numerical input by that result.
            #[prost(message, tag = "3")]
            Job(super::super::OracleJob),
            /// / A stringified big.js. `Accepts variable expansion syntax.`
            #[prost(string, tag = "4")]
            Big(::prost::alloc::string::String),
        }
    }
    ///
    /// This task will multiply a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
    ///
    /// _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the numerical result by multiplying by a job of subtasks.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"multiplyTask":{"job":{"tasks":[{"valueTask":{"value":10}}\]}}}]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by multiplying by an aggregator.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"multiplyTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}\]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by multiplying by a big.
    ///
    /// ```json
    /// {"tasks":\[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}\]}}]}},{"valueTask":{"value":100}},{"multiplyTask":{"big":"${TEN}"}}]}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultiplyTask {
        #[prost(oneof = "multiply_task::Multiple", tags = "1, 2, 3, 4")]
        pub multiple: ::core::option::Option<multiply_task::Multiple>,
    }
    /// Nested message and enum types in `MultiplyTask`.
    pub mod multiply_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Multiple {
            /// / Specifies a scalar to multiply by.
            #[prost(double, tag = "1")]
            Scalar(f64),
            /// / Specifies an aggregator to multiply by.
            #[prost(string, tag = "2")]
            AggregatorPubkey(::prost::alloc::string::String),
            /// / A job whose result is computed before multiplying our numerical input by that result.
            #[prost(message, tag = "3")]
            Job(super::super::OracleJob),
            /// / A stringified big.js. `Accepts variable expansion syntax.`
            #[prost(string, tag = "4")]
            Big(::prost::alloc::string::String),
        }
    }
    ///
    /// This task will add a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
    ///
    /// _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the numerical result by adding by a job of subtasks.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"addTask":{"job":{"tasks":[{"valueTask":{"value":10}}\]}}}]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by multiplying by an aggregator.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"addTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}\]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by multiplying by a big.
    ///
    /// ```json
    /// {"tasks":\[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}\]}}]}},{"valueTask":{"value":100}},{"addTask":{"big":"${TEN}"}}]}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddTask {
        #[prost(oneof = "add_task::Addition", tags = "1, 2, 3, 4")]
        pub addition: ::core::option::Option<add_task::Addition>,
    }
    /// Nested message and enum types in `AddTask`.
    pub mod add_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Addition {
            /// / Specifies a scalar to add by.
            #[prost(double, tag = "1")]
            Scalar(f64),
            /// / Specifies an aggregator to add by.
            #[prost(string, tag = "2")]
            AggregatorPubkey(::prost::alloc::string::String),
            /// / A job whose result is computed before adding our numerical input by that result.
            #[prost(message, tag = "3")]
            Job(super::super::OracleJob),
            /// / A stringified big.js. `Accepts variable expansion syntax.`
            #[prost(string, tag = "4")]
            Big(::prost::alloc::string::String),
        }
    }
    ///
    /// This task will subtract a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
    ///
    /// _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
    ///
    /// _**Returns**_: A numerical result.
    ///
    /// _**Example**_: Returns the numerical result by subtracting by a job of subtasks.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"subtractTask":{"job":{"tasks":[{"valueTask":{"value":10}}\]}}}]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by multiplying by an aggregator.
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":100}},{"subtractTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}\]}
    /// ```
    ///
    /// _**Example**_: Returns the numerical result by multiplying by a big.
    ///
    /// ```json
    /// {"tasks":\[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}\]}}]}},{"valueTask":{"value":100}},{"subtractTask":{"big":"${TEN}"}}]}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubtractTask {
        #[prost(oneof = "subtract_task::Subtraction", tags = "1, 2, 3, 4")]
        pub subtraction: ::core::option::Option<subtract_task::Subtraction>,
    }
    /// Nested message and enum types in `SubtractTask`.
    pub mod subtract_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Subtraction {
            /// / Specifies a scalar to subtract by.
            #[prost(double, tag = "1")]
            Scalar(f64),
            /// / Specifies an aggregator to subtract by.
            #[prost(string, tag = "2")]
            AggregatorPubkey(::prost::alloc::string::String),
            /// / A job whose result is computed before subtracting our numerical input by that result.
            #[prost(message, tag = "3")]
            Job(super::super::OracleJob),
            /// / A stringified big.js. `Accepts variable expansion syntax.`
            #[prost(string, tag = "4")]
            Big(::prost::alloc::string::String),
        }
    }
    ///
    /// Fetch LP token price info from a number of supported exchanges.
    ///
    /// See our blog post on [Fair LP Token Oracles](/blog/2022/01/20/Fair-LP-Token-Oracles)
    ///
    /// *NOTE**: This is not the swap price but the price of the underlying LP token.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The price of an LP token for a given AMM pool.
    ///
    /// _**Example**_: Fetch the Orca LP token price of the SOL/USDC pool
    ///
    /// ```json
    /// { "lpTokenPriceTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9" } }
    /// ```
    ///
    /// _**Example**_: Fetch the fair price Orca LP token price of the SOL/USDC pool
    ///
    /// ```json
    /// { "lpTokenPriceTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9", "useFairPrice": true, "priceFeedAddresses": \[ "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR", "BjUgj6YCnFBZ49wF54ddBVA9qu8TeqkFtkbqmZcee8uW" \] } }
    /// ```
    ///
    /// _**Example**_: Fetch the fair price Raydium LP token price of the SOL/USDC pool
    ///
    /// ```json
    /// { "lpTokenPriceTask": { "raydiumPoolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", "useFairPrice": true,"priceFeedAddresses": \["GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR","BjUgj6YCnFBZ49wF54ddBVA9qu8TeqkFtkbqmZcee8uW" \] } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LpTokenPriceTask {
        /// / A list of Switchboard aggregator accounts used to calculate the fair LP price. This ensures the price is based on the previous round to mitigate flash loan price manipulation.
        #[prost(string, repeated, tag = "5")]
        pub price_feed_addresses: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// / A list of OracleJobs to execute in order to yield the price feed jobs to use for the fair price formula.
        #[prost(message, repeated, tag = "6")]
        pub price_feed_jobs: ::prost::alloc::vec::Vec<super::OracleJob>,
        /// / If enabled and price_feed_addresses provided, the oracle will calculate the fair LP price based on the liquidity pool reserves. See our blog post for more information: <https://switchboardxyz.medium.com/fair-lp-token-oracles-94a457c50239>
        #[prost(bool, optional, tag = "7")]
        pub use_fair_price: ::core::option::Option<bool>,
        #[prost(oneof = "lp_token_price_task::PoolAddress", tags = "1, 2, 3, 4")]
        pub pool_address: ::core::option::Option<lp_token_price_task::PoolAddress>,
    }
    /// Nested message and enum types in `LpTokenPriceTask`.
    pub mod lp_token_price_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PoolAddress {
            /// / Mercurial finance pool address. A full list can be found here: <https://github.com/mercurial-finance/stable-swap-n-pool-js>
            #[prost(string, tag = "1")]
            MercurialPoolAddress(::prost::alloc::string::String),
            /// / Saber pool address. A full list can be found here: <https://github.com/saber-hq/saber-registry-dist>
            #[prost(string, tag = "2")]
            SaberPoolAddress(::prost::alloc::string::String),
            /// / Orca pool address. A full list can be found here: <https://www.orca.so/pools>
            #[prost(string, tag = "3")]
            OrcaPoolAddress(::prost::alloc::string::String),
            /// / The Raydium liquidity pool ammId. A full list can be found here: <https://raydium.io/pools>
            #[prost(string, tag = "4")]
            RaydiumPoolAddress(::prost::alloc::string::String),
        }
    }
    ///
    /// Fetch the current swap price for a given liquidity pool
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The swap price for a given AMM pool.
    ///
    /// _**Example**_: Fetch the exchange rate from the Orca SOL/USDC pool
    ///
    /// ```json
    /// { "lpExchangeRateTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9" } }
    /// ```
    ///
    /// _**Example**_: Fetch the exchange rate from the Raydium SOL/USDC pool
    ///
    /// ```json
    /// { "lpExchangeRateTask": { "raydiumPoolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LpExchangeRateTask {
        /// / Used alongside mercurial_pool_address to specify the input token for a swap.
        #[prost(string, optional, tag = "1")]
        pub in_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / Used alongside mercurial_pool_address to specify the output token for a swap.
        #[prost(string, optional, tag = "2")]
        pub out_token_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration = "lp_exchange_rate_task::Chain", optional, tag = "9")]
        pub chain: ::core::option::Option<i32>,
        #[prost(oneof = "lp_exchange_rate_task::PoolAddress", tags = "3, 4, 5, 6, 7, 8")]
        pub pool_address: ::core::option::Option<lp_exchange_rate_task::PoolAddress>,
    }
    /// Nested message and enum types in `LpExchangeRateTask`.
    pub mod lp_exchange_rate_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Chain {
            Solana = 0,
            Eclipse = 1,
        }
        impl Chain {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Solana => "SOLANA",
                    Self::Eclipse => "ECLIPSE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SOLANA" => Some(Self::Solana),
                    "ECLIPSE" => Some(Self::Eclipse),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PoolAddress {
            /// / Mercurial finance pool address. A full list can be found here: <https://github.com/mercurial-finance/stable-swap-n-pool-js>
            #[prost(string, tag = "3")]
            MercurialPoolAddress(::prost::alloc::string::String),
            /// / Saber pool address. A full list can be found here: <https://github.com/saber-hq/saber-registry-dist>
            #[prost(string, tag = "4")]
            SaberPoolAddress(::prost::alloc::string::String),
            /// / **@deprecated** Use orcaPoolAddress
            #[prost(string, tag = "5")]
            OrcaPoolTokenMintAddress(::prost::alloc::string::String),
            /// / The Raydium liquidity pool ammId. A full list can be found here: <https://raydium.io/pools>
            #[prost(string, tag = "6")]
            RaydiumPoolAddress(::prost::alloc::string::String),
            /// / Pool address for an Orca LP pool or whirlpool.
            /// / A full list of Orca LP pools can be found here: <https://www.orca.so/pools>
            #[prost(string, tag = "7")]
            OrcaPoolAddress(::prost::alloc::string::String),
            /// / The Port reserve pubkey. A full list can be found here: <https://api-v1.port.finance/reserves>
            #[prost(string, tag = "8")]
            PortReserveAddress(::prost::alloc::string::String),
        }
    }
    ///
    /// Find and extract text using regular expressions from the previous task's output.
    ///
    /// _**Input**_: String output from previous task
    ///
    /// _**Returns**_: The matched string based on the regex pattern and group number
    ///
    /// _**Example**_: Extract the first number from a string
    ///
    /// ```json
    /// {
    /// "regexExtractTask": {
    /// "pattern": "\\d+",
    /// "groupNumber": 0
    /// }
    /// }
    /// ```
    ///
    /// _**Example**_: Extract text between quotes
    ///
    /// ```json
    /// {
    /// "regexExtractTask": {
    /// "pattern": "\"(\[^\"\]+)\"",
    /// "groupNumber": 1
    /// }
    /// }
    /// ```
    ///
    /// _**Example**_: Extract the first JSON object from a stream
    ///
    /// ```json
    /// {
    /// "regexExtractTask": {
    /// "pattern": "\\{\[^}\]+\\}"
    /// }
    /// }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RegexExtractTask {
        /// / The regular expression pattern to match against the input string.
        /// / Uses the fancy-regex Rust crate syntax.
        #[prost(string, optional, tag = "1")]
        pub pattern: ::core::option::Option<::prost::alloc::string::String>,
        /// / The capture group number to extract (0 returns full match, 1+ returns respective capture group).
        /// / Defaults to 0 if not specified.
        #[prost(int32, optional, tag = "2")]
        pub group_number: ::core::option::Option<i32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct XStepPriceTask {
        #[prost(oneof = "x_step_price_task::StepSource", tags = "1, 2")]
        pub step_source: ::core::option::Option<x_step_price_task::StepSource>,
    }
    /// Nested message and enum types in `XStepPriceTask`.
    pub mod x_step_price_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum StepSource {
            /// / median task containing the job definitions to fetch the STEP/USD price
            #[prost(message, tag = "1")]
            StepJob(super::MedianTask),
            /// / existing aggregator pubkey for STEP/USD
            #[prost(string, tag = "2")]
            StepAggregatorPubkey(::prost::alloc::string::String),
        }
    }
    ///
    /// Takes a twap over a set period for a certain aggregator. Aggregators have an optional history buffer account storing the last N accepted results. The TwapTask will iterate over an aggregators history buffer and calculate the time weighted average of the samples within a given time period.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The time weighted average of an aggregator over a given time period.
    ///
    /// _**Example**_: The 1hr Twap of the SOL/USD Aggregator, requiring at least 60 samples.
    ///
    /// ```json
    /// { "twapTask": { "aggregatorPubkey": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR", "period": 3600, "minSamples": 60, "weightByPropagationTime": true  } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TwapTask {
        /// / The target aggregator for the TWAP.
        #[prost(string, optional, tag = "1")]
        pub aggregator_pubkey: ::core::option::Option<::prost::alloc::string::String>,
        /// / Period, in seconds, the twap should account for
        #[prost(int32, optional, tag = "2")]
        pub period: ::core::option::Option<i32>,
        /// / Weight samples by their propagation time
        #[prost(bool, optional, tag = "3")]
        pub weight_by_propagation_time: ::core::option::Option<bool>,
        /// / Minimum number of samples in the history to calculate a valid result
        #[prost(uint32, optional, tag = "4")]
        pub min_samples: ::core::option::Option<u32>,
        /// / Ending unix timestamp to collect values up to
        #[prost(int32, optional, tag = "5")]
        pub ending_unix_timestamp: ::core::option::Option<i32>,
        /// / Execute the task to get the ending unix timestamp
        #[prost(message, optional, tag = "6")]
        pub ending_unix_timestamp_task: ::core::option::Option<CronParseTask>,
    }
    /// / Fetch the latest swap price on Serum's orderbook
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SerumSwapTask {
        /// / The serum pool to fetch swap price for
        #[prost(string, optional, tag = "1")]
        pub serum_pool_address: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Round the current running result to an exponential power.
    ///
    /// _**Input**_: The current running numerical result.
    ///
    /// _**Returns**_: The input raised to an exponential power.
    ///
    /// _**Example**_: Raise 2 to the power of 3, 2^3
    ///
    /// ```json
    /// {"tasks":\[{"valueTask":{"value":2}},{"powTask":{"scalar":3}}\]}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PowTask {
        #[prost(oneof = "pow_task::Exponent", tags = "1, 2, 3")]
        pub exponent: ::core::option::Option<pow_task::Exponent>,
    }
    /// Nested message and enum types in `PowTask`.
    pub mod pow_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Exponent {
            /// / Take the working value to the exponent of value.
            #[prost(double, tag = "1")]
            Scalar(f64),
            /// / Take the working value to the exponent of the aggregators value.
            #[prost(string, tag = "2")]
            AggregatorPubkey(::prost::alloc::string::String),
            /// / A stringified big.js. `Accepts variable expansion syntax.`
            #[prost(string, tag = "3")]
            Big(::prost::alloc::string::String),
        }
    }
    /// / Fetch the lending rates for various Solana protocols
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LendingRateTask {
        /// / 01, apricot, francium, jet, larix, mango, port, solend, tulip
        #[prost(string, optional, tag = "1")]
        pub protocol: ::core::option::Option<::prost::alloc::string::String>,
        /// / A token mint address supported by the chosen protocol
        #[prost(string, optional, tag = "2")]
        pub asset_mint: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration = "lending_rate_task::Field", optional, tag = "3")]
        pub field: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `LendingRateTask`.
    pub mod lending_rate_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Field {
            /// / deposit lending rate
            DepositRate = 0,
            /// / borrow lending rate
            BorrowRate = 1,
        }
        impl Field {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::DepositRate => "FIELD_DEPOSIT_RATE",
                    Self::BorrowRate => "FIELD_BORROW_RATE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FIELD_DEPOSIT_RATE" => Some(Self::DepositRate),
                    "FIELD_BORROW_RATE" => Some(Self::BorrowRate),
                    _ => None,
                }
            }
        }
    }
    /// / Fetch the current price for a Mango perpetual market
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MangoPerpMarketTask {
        /// / Mainnet address for a mango perpetual market. A full list can be found here: <https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json>
        #[prost(string, optional, tag = "1")]
        pub perp_market_address: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Fetch the simulated price for a swap on JupiterSwap.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The swap price on Jupiter for a given input and output token mint address.
    ///
    /// _**Example**_: Fetch the JupiterSwap price for exchanging 1 SOL into USDC.
    ///
    /// ```json
    /// { "jupiterSwapTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" } }
    /// ```
    ///
    /// _**Example**_: Fetch the JupiterSwap price for exchanging 1000 SOL into USDC.
    ///
    /// ```json
    /// { "jupiterSwapTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "baseAmount": "1000" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JupiterSwapTask {
        /// / The input token address.
        #[prost(string, optional, tag = "1")]
        pub in_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The output token address.
        #[prost(string, optional, tag = "2")]
        pub out_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The allowable slippage on the swap in decimal form (e.g. 0.5 is 0.5% slippage)
        #[prost(double, optional, tag = "9")]
        pub slippage: ::core::option::Option<f64>,
        #[prost(enumeration = "jupiter_swap_task::Version", optional, tag = "10")]
        pub version: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "11")]
        pub direct_routes_only: ::core::option::Option<bool>,
        /// / Optional API key for authenticated requests
        #[prost(string, optional, tag = "12")]
        pub api_key: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(oneof = "jupiter_swap_task::RoutesFilters", tags = "4, 5")]
        pub routes_filters: ::core::option::Option<jupiter_swap_task::RoutesFilters>,
        #[prost(oneof = "jupiter_swap_task::SwapAmount", tags = "3, 6, 7, 8")]
        pub swap_amount: ::core::option::Option<jupiter_swap_task::SwapAmount>,
    }
    /// Nested message and enum types in `JupiterSwapTask`.
    pub mod jupiter_swap_task {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FilterList {
            /// / A list of Jupiter AMM labels to allow or deny (e.g. 'Raydium', 'Orca')
            #[prost(string, repeated, tag = "1")]
            pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Version {
            V1 = 0,
            V2 = 1,
        }
        impl Version {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::V1 => "VERSION_V1",
                    Self::V2 => "VERSION_V2",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "VERSION_V1" => Some(Self::V1),
                    "VERSION_V2" => Some(Self::V2),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum RoutesFilters {
            /// / A list of AMM markets to allow.
            #[prost(message, tag = "4")]
            AllowList(FilterList),
            /// / A list of AMM markets to deny.
            #[prost(message, tag = "5")]
            DenyList(FilterList),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum SwapAmount {
            /// / The amount of `in_token_address` tokens to swap.
            #[prost(double, tag = "3")]
            BaseAmount(f64),
            /// / The amount of `out_token_address` tokens to swap.
            #[prost(double, tag = "6")]
            QuoteAmount(f64),
            /// / The amount of `in_token_address` tokens to swap.
            #[prost(string, tag = "7")]
            BaseAmountString(::prost::alloc::string::String),
            /// / The amount of `out_token_address` tokens to swap.
            #[prost(string, tag = "8")]
            QuoteAmountString(::prost::alloc::string::String),
        }
    }
    ///
    /// Fetch the simulated swap price from Titan API.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The swap price on Titan for a given input and output token mint address.
    ///
    /// _**Example**_: Fetch the Titan price for exchanging 1 SOL into USDC.
    ///
    /// ```json
    /// { "titanTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" } }
    /// ```
    ///
    /// _**Example**_: Fetch the Titan price for exchanging 1000 SOL into USDC with slippage.
    ///
    /// ```json
    /// { "titanTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "amount": "1000", "slippageBps": 50 } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TitanTask {
        /// / The input token mint address (base58 encoded).
        #[prost(string, optional, tag = "1")]
        pub in_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The output token mint address (base58 encoded).
        #[prost(string, optional, tag = "2")]
        pub out_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The amount of tokens to swap (raw atoms, not scaled by decimals).
        #[prost(string, optional, tag = "3")]
        pub amount: ::core::option::Option<::prost::alloc::string::String>,
        /// / Optional user public key for transaction generation (base58 encoded).
        #[prost(string, optional, tag = "4")]
        pub user_public_key: ::core::option::Option<::prost::alloc::string::String>,
        /// / Whether the amount is in terms of input or output token. Defaults to ExactIn.
        #[prost(enumeration = "titan_task::SwapMode", optional, tag = "5")]
        pub swap_mode: ::core::option::Option<i32>,
        /// / Allowed slippage in basis points (e.g., 50 = 0.5%).
        #[prost(uint32, optional, tag = "6")]
        pub slippage_bps: ::core::option::Option<u32>,
        /// / If set, constrain quotes to the given set of DEXes.
        #[prost(message, optional, tag = "7")]
        pub dexes: ::core::option::Option<titan_task::FilterList>,
        /// / If set, exclude the following DEXes when determining routes.
        #[prost(message, optional, tag = "8")]
        pub exclude_dexes: ::core::option::Option<titan_task::FilterList>,
        /// / If set to true, only direct routes between the input and output mint will be considered.
        #[prost(bool, optional, tag = "9")]
        pub only_direct_routes: ::core::option::Option<bool>,
        /// / If set, limit quotes to the given set of provider IDs.
        #[prost(string, repeated, tag = "10")]
        pub providers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// / Optional API access token for authenticated requests
        #[prost(string, optional, tag = "11")]
        pub access_token: ::core::option::Option<::prost::alloc::string::String>,
        /// / Optional API endpoint override (defaults to partners.api.titan.exchange)
        #[prost(string, optional, tag = "12")]
        pub api_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `TitanTask`.
    pub mod titan_task {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FilterList {
            /// / A list of DEX labels to allow or deny (e.g., 'Raydium', 'Orca')
            #[prost(string, repeated, tag = "1")]
            pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SwapMode {
            /// / The amount is in terms of the input token.
            ExactIn = 0,
            /// / The amount is in terms of the output token.
            ExactOut = 1,
        }
        impl SwapMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ExactIn => "SWAP_MODE_EXACT_IN",
                    Self::ExactOut => "SWAP_MODE_EXACT_OUT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SWAP_MODE_EXACT_IN" => Some(Self::ExactIn),
                    "SWAP_MODE_EXACT_OUT" => Some(Self::ExactOut),
                    _ => None,
                }
            }
        }
    }
    /// / Hylo Protocol task for converting 1 hyUSD to jitoSOL.
    /// / hyUSD is a stablecoin with NAV pegged to $1.00 USD.
    /// / Converts exactly 1 hyUSD token to jitoSOL.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct HyloTask {
        /// / The Hylo token to convert from (defaults to hyUSD)
        #[prost(enumeration = "hylo_task::Token", optional, tag = "1")]
        pub token: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `HyloTask`.
    pub mod hylo_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Token {
            /// / Hylo USD stablecoin (hyUSD) - pegged to $1.00 USD
            Hyusd = 0,
        }
        impl Token {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Hyusd => "TOKEN_HYUSD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TOKEN_HYUSD" => Some(Self::Hyusd),
                    _ => None,
                }
            }
        }
    }
    /// / Fetch the current price of a perpetual market.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerpMarketTask {
        #[prost(oneof = "perp_market_task::MarketAddress", tags = "1, 2, 3, 4")]
        pub market_address: ::core::option::Option<perp_market_task::MarketAddress>,
    }
    /// Nested message and enum types in `PerpMarketTask`.
    pub mod perp_market_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum MarketAddress {
            /// / Market address for a mango perpetual market. A full list can be found here: <https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json>
            #[prost(string, tag = "1")]
            MangoMarketAddress(::prost::alloc::string::String),
            /// / Market address for a drift perpetual market. A full list can be found here: <https://github.com/drift-labs/protocol-v1/blob/master/sdk/src/constants/markets.ts>
            #[prost(string, tag = "2")]
            DriftMarketAddress(::prost::alloc::string::String),
            /// / Market address for a zeta perpetual market.
            #[prost(string, tag = "3")]
            ZetaMarketAddress(::prost::alloc::string::String),
            /// / Market address for a 01 protocol perpetual market.
            #[prost(string, tag = "4")]
            ZoMarketAddress(::prost::alloc::string::String),
        }
    }
    ///
    /// Fetch the current price of a Solana oracle protocol.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The current price of an on-chain oracle.
    ///
    /// _**Example**_: The Switchboard SOL/USD oracle price.
    ///
    /// ```json
    /// { "oracleTask": { "switchboardAddress": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR" } }
    /// ```
    ///
    /// _**Example**_: The Pyth SOL/USD oracle price.
    ///
    /// ```json
    /// { "oracleTask": { "pythAddress": "H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG" } }
    /// ```
    ///
    /// _**Example**_: The Chainlink SOL/USD oracle price.
    ///
    /// ```json
    /// { "oracleTask": { "chainlinkAddress": "CcPVS9bqyXbD9cLnTbhhHazLsrua8QMFUHTutPtjyDzq" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OracleTask {
        /// / Value (as a percentage) that the lower bound confidence interval is of the actual value.
        /// / Confidence intervals that are larger that this treshold are rejected.
        /// /
        /// / The confidence interval should be provided as a raw percentage value. For example, to
        /// / represent 10%, enter the value as 10, not 0.1.
        ///
        /// Deprecated "pyth_allowed_confidence_interval"
        #[prost(double, optional, tag = "4")]
        pub pyth_allowed_confidence_interval: ::core::option::Option<f64>,
        #[prost(message, optional, tag = "5")]
        pub chainlink_configs: ::core::option::Option<oracle_task::ChainlinkConfigs>,
        #[prost(message, optional, tag = "6")]
        pub pyth_configs: ::core::option::Option<oracle_task::PythConfigs>,
        #[prost(message, optional, tag = "9")]
        pub switchboard_configs: ::core::option::Option<oracle_task::SwitchboardConfigs>,
        #[prost(message, optional, tag = "10")]
        pub edge_configs: ::core::option::Option<oracle_task::EdgeConfigs>,
        #[prost(message, optional, tag = "11")]
        pub redstone_configs: ::core::option::Option<oracle_task::RedstoneConfigs>,
        #[prost(oneof = "oracle_task::AggregatorAddress", tags = "1, 2, 3, 7, 8")]
        pub aggregator_address: ::core::option::Option<oracle_task::AggregatorAddress>,
    }
    /// Nested message and enum types in `OracleTask`.
    pub mod oracle_task {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ChainlinkConfigs {
            #[prost(string, optional, tag = "1")]
            pub provider: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PythConfigs {
            #[prost(string, optional, tag = "1")]
            pub hermes_url: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(double, optional, tag = "2")]
            pub pyth_allowed_confidence_interval: ::core::option::Option<f64>,
            #[prost(int32, optional, tag = "3")]
            pub max_stale_seconds: ::core::option::Option<i32>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SwitchboardConfigs {
            #[prost(int32, optional, tag = "1")]
            pub version: ::core::option::Option<i32>,
            #[prost(message, repeated, tag = "2")]
            pub jobs: ::prost::alloc::vec::Vec<super::super::OracleJob>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct EdgeConfigs {}
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct RedstoneConfigs {}
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum AggregatorAddress {
            /// / Mainnet address of a Switchboard feed. Switchboard is decentralized and allows anyone to build their own feed.
            #[prost(string, tag = "1")]
            SwitchboardAddress(::prost::alloc::string::String),
            /// / Mainnet address for a Pyth feed. A full list can be found here: <https://pyth.network/price-feeds/>
            #[prost(string, tag = "2")]
            PythAddress(::prost::alloc::string::String),
            /// / Mainnet address for a Chainlink feed. A full list can be found here: <https://docs.chain.link/docs/solana/data-feeds-solana>
            #[prost(string, tag = "3")]
            ChainlinkAddress(::prost::alloc::string::String),
            #[prost(string, tag = "7")]
            EdgeId(::prost::alloc::string::String),
            #[prost(string, tag = "8")]
            RedstoneId(::prost::alloc::string::String),
        }
    }
    /// / Load a parse an Anchor based solana account.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnchorFetchTask {
        /// / Owning program of the account to parse.
        #[prost(string, optional, tag = "1")]
        pub program_id: ::core::option::Option<::prost::alloc::string::String>,
        /// / The account to parse.
        #[prost(string, optional, tag = "2")]
        pub account_address: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// / Fetch the JSON representation of an SPL Stake Pool account.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SplStakePoolTask {
        /// / The pubkey of the SPL Stake Pool.
        #[prost(string, optional, tag = "1")]
        pub pubkey: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// / Fetch the JSON representation of an SPL token mint.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SplTokenParseTask {
        #[prost(oneof = "spl_token_parse_task::AccountAddress", tags = "1, 2")]
        pub account_address: ::core::option::Option<
            spl_token_parse_task::AccountAddress,
        >,
    }
    /// Nested message and enum types in `SplTokenParseTask`.
    pub mod spl_token_parse_task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum AccountAddress {
            /// / The publicKey of a token account to fetch the mintInfo for.
            #[prost(string, tag = "1")]
            TokenAccountAddress(::prost::alloc::string::String),
            /// / The publicKey of the token mint address.
            #[prost(string, tag = "2")]
            MintAddress(::prost::alloc::string::String),
        }
    }
    /// / Fetch the swap price from UniSwap.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UniswapExchangeRateTask {
        /// / The input token address.
        #[prost(string, optional, tag = "1")]
        pub in_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The output token address.
        #[prost(string, optional, tag = "2")]
        pub out_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The amount of tokens to swap.
        #[prost(double, optional, tag = "3")]
        pub in_token_amount: ::core::option::Option<f64>,
        /// / The allowable slippage in percent for the swap.
        #[prost(double, optional, tag = "4")]
        pub slippage: ::core::option::Option<f64>,
        /// / The RPC provider to use for the swap.
        #[prost(string, optional, tag = "5")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
        /// / The version of the Uniswap exchange to use.
        #[prost(
            enumeration = "uniswap_exchange_rate_task::Version",
            optional,
            tag = "6"
        )]
        pub version: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "7")]
        pub router_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "8")]
        pub factory_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "9")]
        pub quoter_address: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `UniswapExchangeRateTask`.
    pub mod uniswap_exchange_rate_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Version {
            V2Deprecated = 0,
            V3Deprecated = 1,
            V2 = 2,
            V3 = 3,
        }
        impl Version {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::V2Deprecated => "VERSION_V2_DEPRECATED",
                    Self::V3Deprecated => "VERSION_V3_DEPRECATED",
                    Self::V2 => "VERSION_V2",
                    Self::V3 => "VERSION_V3",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "VERSION_V2_DEPRECATED" => Some(Self::V2Deprecated),
                    "VERSION_V3_DEPRECATED" => Some(Self::V3Deprecated),
                    "VERSION_V2" => Some(Self::V2),
                    "VERSION_V3" => Some(Self::V3),
                    _ => None,
                }
            }
        }
    }
    /// / Fetch the swap price from SushiSwap.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SushiswapExchangeRateTask {
        /// / The input token address.
        #[prost(string, optional, tag = "1")]
        pub in_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The output token address.
        #[prost(string, optional, tag = "2")]
        pub out_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The amount of tokens to swap.
        #[prost(double, optional, tag = "3")]
        pub in_token_amount: ::core::option::Option<f64>,
        /// / The allowable slippage in percent for the swap.
        #[prost(double, optional, tag = "4")]
        pub slippage: ::core::option::Option<f64>,
        /// / The RPC provider to use for the swap.
        #[prost(string, optional, tag = "5")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// / Fetch the swap price from PancakeSwap.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PancakeswapExchangeRateTask {
        /// / The input token address.
        #[prost(string, optional, tag = "1")]
        pub in_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The output token address.
        #[prost(string, optional, tag = "2")]
        pub out_token_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The amount of tokens to swap.
        #[prost(double, optional, tag = "3")]
        pub in_token_amount: ::core::option::Option<f64>,
        /// / The allowable slippage in percent for the swap.
        #[prost(double, optional, tag = "4")]
        pub slippage: ::core::option::Option<f64>,
        /// / The RPC provider to use for the swap.
        #[prost(string, optional, tag = "5")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Execute a job and store the result in a variable to reference later.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The input
    ///
    /// _**Example**_: CacheTask storing ${ONE} = 1
    ///
    /// ```json
    /// { "cacheTask": { "cacheItems": \[ { "variableName": "ONE", "job": { "tasks": [ { "valueTask": { "value": 1 } } \] } } ] } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CacheTask {
        /// / A list of cached variables to reference in the job with `${VARIABLE_NAME}`.
        #[prost(message, repeated, tag = "1")]
        pub cache_items: ::prost::alloc::vec::Vec<cache_task::CacheItem>,
    }
    /// Nested message and enum types in `CacheTask`.
    pub mod cache_task {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CacheItem {
            /// / The name of the variable to store in cache to reference later with `${VARIABLE_NAME}`.
            #[prost(string, optional, tag = "1")]
            pub variable_name: ::core::option::Option<::prost::alloc::string::String>,
            /// / The OracleJob to execute to yield the value to store in cache.
            #[prost(message, optional, tag = "2")]
            pub job: ::core::option::Option<super::super::OracleJob>,
        }
    }
    /// / Return the difference between an oracle's clock and the current timestamp at `SYSVAR_CLOCK_PUBKEY`.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SysclockOffsetTask {}
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MarinadeStateTask {}
    /// / Fetch the account data in a stringified buffer format.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SolanaAccountDataFetchTask {
        /// / The on-chain account to fetch the account data from.
        #[prost(string, optional, tag = "1")]
        pub pubkey: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(
            enumeration = "solana_account_data_fetch_task::Network",
            optional,
            tag = "2"
        )]
        pub network: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `SolanaAccountDataFetchTask`.
    pub mod solana_account_data_fetch_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Network {
            Mainnet = 0,
            Testnet = 1,
            Devnet = 2,
        }
        impl Network {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Mainnet => "NETWORK_MAINNET",
                    Self::Testnet => "NETWORK_TESTNET",
                    Self::Devnet => "NETWORK_DEVNET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NETWORK_MAINNET" => Some(Self::Mainnet),
                    "NETWORK_TESTNET" => Some(Self::Testnet),
                    "NETWORK_DEVNET" => Some(Self::Devnet),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Return a timestamp from a crontab instruction.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: A timestamp
    ///
    /// _**Example**_: Return the unix timestamp for the on-chain SYSCLOCK
    ///
    /// ```json
    /// {"cronParseTask":{"cronPattern":"* * * * * *","clockOffset":0,"clock":"SYSCLOCK"}}
    /// ```
    ///
    /// _**Example**_: Return the unix timestamp for next friday at 5pm UTC
    ///
    /// ```json
    /// {"cronParseTask":{"cronPattern":"0 17 * * 5","clockOffset":0,"clock":0}}
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CronParseTask {
        /// / The cron pattern to parse.
        #[prost(string, optional, tag = "1")]
        pub cron_pattern: ::core::option::Option<::prost::alloc::string::String>,
        /// / The timestamp offset to calculate the next run.
        #[prost(int32, optional, tag = "2")]
        pub clock_offset: ::core::option::Option<i32>,
        /// / Use the TaskRunner's clock or the on-chain SYSCLOCK.
        #[prost(enumeration = "cron_parse_task::ClockType", optional, tag = "3")]
        pub clock: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `CronParseTask`.
    pub mod cron_parse_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ClockType {
            /// / Use the TaskRunners system clock for the current time.
            Oracle = 0,
            /// / Use the on-chain SYSCLOCK for the current time.
            Sysclock = 1,
        }
        impl ClockType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Oracle => "ORACLE",
                    Self::Sysclock => "SYSCLOCK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ORACLE" => Some(Self::Oracle),
                    "SYSCLOCK" => Some(Self::Sysclock),
                    _ => None,
                }
            }
        }
    }
    /// / Return the deserialized value from a stringified buffer.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BufferLayoutParseTask {
        /// / The buffer offset to start deserializing from.
        #[prost(uint32, optional, tag = "1")]
        pub offset: ::core::option::Option<u32>,
        /// / The endianness of the stored value.
        #[prost(enumeration = "buffer_layout_parse_task::Endian", optional, tag = "2")]
        pub endian: ::core::option::Option<i32>,
        /// / The type of value to deserialize.
        #[prost(
            enumeration = "buffer_layout_parse_task::BufferParseType",
            optional,
            tag = "3"
        )]
        pub r#type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `BufferLayoutParseTask`.
    pub mod buffer_layout_parse_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Endian {
            /// Use little endian byte order.
            LittleEndian = 0,
            /// Use big endian byte order.
            BigEndian = 1,
        }
        impl Endian {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::LittleEndian => "LITTLE_ENDIAN",
                    Self::BigEndian => "BIG_ENDIAN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LITTLE_ENDIAN" => Some(Self::LittleEndian),
                    "BIG_ENDIAN" => Some(Self::BigEndian),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BufferParseType {
            /// / A public key.
            Pubkey = 1,
            /// / A boolean.
            Bool = 2,
            /// / An 8-bit unsigned value.
            U8 = 3,
            /// / An 8-bit signed value.
            I8 = 4,
            /// / A 16-bit unsigned value.
            U16 = 5,
            /// / A 16-bit signed value.
            I16 = 6,
            /// / A 32-bit unsigned value.
            U32 = 7,
            /// / A 32-bit signed value.
            I32 = 8,
            /// / A 32-bit IEEE floating point value.
            F32 = 9,
            /// / A 64-bit unsigned value.
            U64 = 10,
            /// / A 64-bit signed value.
            I64 = 11,
            /// / A 64-bit IEEE floating point value.
            F64 = 12,
            /// / A 128-bit unsigned value.
            U128 = 13,
            /// / A 128-bit signed value.
            I128 = 14,
        }
        impl BufferParseType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Pubkey => "pubkey",
                    Self::Bool => "bool",
                    Self::U8 => "u8",
                    Self::I8 => "i8",
                    Self::U16 => "u16",
                    Self::I16 => "i16",
                    Self::U32 => "u32",
                    Self::I32 => "i32",
                    Self::F32 => "f32",
                    Self::U64 => "u64",
                    Self::I64 => "i64",
                    Self::F64 => "f64",
                    Self::U128 => "u128",
                    Self::I128 => "i128",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "pubkey" => Some(Self::Pubkey),
                    "bool" => Some(Self::Bool),
                    "u8" => Some(Self::U8),
                    "i8" => Some(Self::I8),
                    "u16" => Some(Self::U16),
                    "i16" => Some(Self::I16),
                    "u32" => Some(Self::U32),
                    "i32" => Some(Self::I32),
                    "f32" => Some(Self::F32),
                    "u64" => Some(Self::U64),
                    "i64" => Some(Self::I64),
                    "f64" => Some(Self::F64),
                    "u128" => Some(Self::U128),
                    "i128" => Some(Self::I128),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HistoryFunctionTask {
        #[prost(enumeration = "history_function_task::Method", optional, tag = "1")]
        pub method: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub aggregator_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub period: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `HistoryFunctionTask`.
    pub mod history_function_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Method {
            Min = 0,
            Max = 1,
        }
        impl Method {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Min => "METHOD_MIN",
                    Self::Max => "METHOD_MAX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "METHOD_MIN" => Some(Self::Min),
                    "METHOD_MAX" => Some(Self::Max),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VwapTask {
        #[prost(string, optional, tag = "1")]
        pub price_aggregator_address: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(string, optional, tag = "2")]
        pub volume_aggregator_address: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(uint32, optional, tag = "3")]
        pub period: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EwmaTask {
        #[prost(string, optional, tag = "1")]
        pub aggregator_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "2")]
        pub period: ::core::option::Option<i32>,
        #[prost(double, optional, tag = "3")]
        pub lambda: ::core::option::Option<f64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComparisonTask {
        /// / The type of operator to use on the left (lhs) and right (rhs) operand.
        #[prost(enumeration = "comparison_task::Operation", optional, tag = "1")]
        pub op: ::core::option::Option<i32>,
        /// / The OracleJob to execute if the condition evaluates to true.
        #[prost(message, optional, tag = "6")]
        pub on_true: ::core::option::Option<super::OracleJob>,
        /// / The result to use if the condition evaluates to true. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "7")]
        pub on_true_value: ::core::option::Option<::prost::alloc::string::String>,
        /// / The OracleJob to execute if the condition evaluates to false.
        #[prost(message, optional, tag = "8")]
        pub on_false: ::core::option::Option<super::OracleJob>,
        /// / The result to use if the condition evaluates to false. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "9")]
        pub on_false_value: ::core::option::Option<::prost::alloc::string::String>,
        /// / The OracleJob to execute if the condition fails to evaluate.
        #[prost(message, optional, tag = "10")]
        pub on_failure: ::core::option::Option<super::OracleJob>,
        /// / The result to use if the condition fails to evaluate. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "11")]
        pub on_failure_value: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(oneof = "comparison_task::Lhs", tags = "2, 3")]
        pub lhs: ::core::option::Option<comparison_task::Lhs>,
        #[prost(oneof = "comparison_task::Rhs", tags = "4, 5")]
        pub rhs: ::core::option::Option<comparison_task::Rhs>,
    }
    /// Nested message and enum types in `ComparisonTask`.
    pub mod comparison_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operation {
            /// / Use the equals to '==' operator.
            Eq = 0,
            /// / Use the greater than '>' operator.
            Gt = 1,
            /// / Use the less than '<' operator.
            Lt = 2,
        }
        impl Operation {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Eq => "OPERATION_EQ",
                    Self::Gt => "OPERATION_GT",
                    Self::Lt => "OPERATION_LT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATION_EQ" => Some(Self::Eq),
                    "OPERATION_GT" => Some(Self::Gt),
                    "OPERATION_LT" => Some(Self::Lt),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Lhs {
            /// / OracleJob where the executed result is equal to the left hand side operand.
            #[prost(message, tag = "2")]
            Lhs(super::super::OracleJob),
            /// / String or `${CACHE_KEY}` representing the left hand side operand.
            #[prost(string, tag = "3")]
            LhsValue(::prost::alloc::string::String),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Rhs {
            /// / OracleJob where the executed result is equal to the right hand side operand.
            #[prost(message, tag = "4")]
            Rhs(super::super::OracleJob),
            /// / String or `${CACHE_KEY}` representing the right hand side operand.
            #[prost(string, tag = "5")]
            RhsValue(::prost::alloc::string::String),
        }
    }
    ///
    /// Round the current running result to a set number of decimal places.
    ///
    /// _**Input**_: The current running numerical result.
    ///
    /// _**Returns**_: The running result rounded to a set number of decimal places.
    ///
    /// _**Example**_: Round down the running resul to 8 decimal places
    ///
    /// ```json
    /// { "roundTask": { "method": "METHOD_ROUND_DOWN", "decimals": 8 } }
    /// ```
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RoundTask {
        /// / The rounding method to use.
        #[prost(enumeration = "round_task::Method", optional, tag = "1")]
        pub method: ::core::option::Option<i32>,
        /// / The number of decimals to round to.
        #[prost(int32, optional, tag = "2")]
        pub decimals: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `RoundTask`.
    pub mod round_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Method {
            /// / Round the result down.
            RoundUp = 0,
            /// / Round the result up.
            RoundDown = 1,
        }
        impl Method {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::RoundUp => "METHOD_ROUND_UP",
                    Self::RoundDown => "METHOD_ROUND_DOWN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "METHOD_ROUND_UP" => Some(Self::RoundUp),
                    "METHOD_ROUND_DOWN" => Some(Self::RoundDown),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Bound the running result to an upper/lower bound. This is typically the last task in an OracleJob.
    ///
    /// _**Input**_: The current running numerical result.
    ///
    /// _**Returns**_: The running result bounded to an upper or lower bound if it exceeds a given threshold.
    ///
    /// _**Example**_: Bound the running result to a value between 0.90 and 1.10
    ///
    /// ```json
    /// { "boundTask": { "lowerBoundValue": "0.90","onExceedsLowerBoundValue": "0.90","upperBoundValue": "1.10","onExceedsUpperBoundValue": "1.10" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoundTask {
        /// / The OracleJob to execute for the lower bound value.
        #[prost(message, optional, tag = "1")]
        pub lower_bound: ::core::option::Option<super::OracleJob>,
        /// / The value to use for the lower bound. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "2")]
        pub lower_bound_value: ::core::option::Option<::prost::alloc::string::String>,
        /// / The OracleJob to execute for the upper bound value.
        #[prost(message, optional, tag = "3")]
        pub upper_bound: ::core::option::Option<super::OracleJob>,
        /// / The value to use for the upper bound. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "4")]
        pub upper_bound_value: ::core::option::Option<::prost::alloc::string::String>,
        /// / The OracleJob to execute if the upper bound is exceeded.
        #[prost(message, optional, tag = "5")]
        pub on_exceeds_upper_bound: ::core::option::Option<super::OracleJob>,
        /// / The value to use if the upper bound is exceeded. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "6")]
        pub on_exceeds_upper_bound_value: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        /// / The OracleJob to execute if the lower bound is exceeded.
        #[prost(message, optional, tag = "7")]
        pub on_exceeds_lower_bound: ::core::option::Option<super::OracleJob>,
        /// / The value to use if the lower bound is exceeded. Can be set to a `${CACHE_KEY}`.
        #[prost(string, optional, tag = "8")]
        pub on_exceeds_lower_bound_value: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
    }
    ///
    /// Securely request secrets from a Switchboard SecretsServer that are owned by a specific authority. Any secrets that are returned for the current feed will then be unwrapped into variables to be accessed later.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The input
    ///
    /// _**Example**_: SecretsTask
    ///
    /// ```json
    /// { "secretsTask": { "authority": "Accb21tUCWocJea6Uk3DgrNZawgmKegDVeHw8cGMDPi5" } }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecretsTask {
        /// / The authority of the secrets that are to be requested.
        #[prost(string, optional, tag = "1")]
        pub authority: ::core::option::Option<::prost::alloc::string::String>,
        /// / The url of the server to request secrets from. The default is <https://api.secrets.switchboard.xyz.>
        #[prost(string, optional, tag = "2")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// / Grab the price of an Sanctum LST relative to SOL.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SanctumLstPriceTask {
        /// / The address of the LST mint.
        /// /
        /// / e.g. INF - 5oVNBeEEQvYi1cX3ir8Dx5n1P7pdxydbGF2X4TxVusJm
        #[prost(string, optional, tag = "1")]
        pub lst_mint: ::core::option::Option<::prost::alloc::string::String>,
        /// / Allow the check to see if the LST was cranked for the current epoch to be skipped.
        #[prost(bool, optional, tag = "2")]
        pub skip_epoch_check: ::core::option::Option<bool>,
    }
    /// / OndoUsdyTask represents a task that computes the price of USDY relative to USD using a
    /// / specified strategy.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OndoUsdyTask {
        /// / The strategy used to determine the price of USDY.
        #[prost(enumeration = "ondo_usdy_task::Strategy", optional, tag = "1")]
        pub strategy: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `OndoUsdyTask`.
    pub mod ondo_usdy_task {
        /// / Strategy specifies the method used to determine the price of USDY.
        /// /
        /// / - STRATEGY_FAIR_VALUE: Computes the price based on a fair value model.
        /// / - STRATEGY_MARKET: Fetches the price directly from the market.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Strategy {
            FairValue = 0,
            Market = 1,
        }
        impl Strategy {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::FairValue => "STRATEGY_FAIR_VALUE",
                    Self::Market => "STRATEGY_MARKET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STRATEGY_FAIR_VALUE" => Some(Self::FairValue),
                    "STRATEGY_MARKET" => Some(Self::Market),
                    _ => None,
                }
            }
        }
    }
    /// / KalshiApiTask fetches a GET endpoint from the Kalshi API (with a token if supplied) and returns the JSON result
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KalshiApiTask {
        /// / A string containing the URL to direct this HTTP request to.
        #[prost(string, optional, tag = "1")]
        pub url: ::core::option::Option<::prost::alloc::string::String>,
        /// / A string containing the API Key ID
        #[prost(string, optional, tag = "2")]
        pub api_key_id: ::core::option::Option<::prost::alloc::string::String>,
        /// / A string containing the private key for authentication
        #[prost(string, optional, tag = "3")]
        pub private_key: ::core::option::Option<::prost::alloc::string::String>,
        /// / Optional signature string field
        #[prost(string, optional, tag = "4")]
        pub signature: ::core::option::Option<::prost::alloc::string::String>,
        /// / Optional timestamp in milliseconds (used with signature)
        #[prost(string, optional, tag = "5")]
        pub timestamp: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// / Grab the swap price from a Meteora pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MeteoraSwapTask {
        /// / The address of the pool.
        #[prost(string, optional, tag = "1")]
        pub pool: ::core::option::Option<::prost::alloc::string::String>,
        /// / The pool type.
        #[prost(enumeration = "meteora_swap_task::Type", optional, tag = "2")]
        pub r#type: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `MeteoraSwapTask`.
    pub mod meteora_swap_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Dlmm = 0,
            Standard = 1,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Dlmm => "TYPE_DLMM",
                    Self::Standard => "TYPE_STANDARD",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_DLMM" => Some(Self::Dlmm),
                    "TYPE_STANDARD" => Some(Self::Standard),
                    _ => None,
                }
            }
        }
    }
    /// / Get current time in seconds since Unix epoch.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UnixTimeTask {
        /// / The offset to subtract from the current time.
        #[prost(int32, optional, tag = "1")]
        pub offset: ::core::option::Option<i32>,
    }
    ///
    /// Fetch pricing information for Maple Finance assets.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The requested price or value based on the specified method.
    ///
    /// _**Example**_: Fetch the syrupUSDC fair price from Maple Finance
    ///
    /// ```json
    /// { "mapleFinanceTask": { "method": "METHOD_SYRUP_USDC_FAIR_PRICE" } }
    /// ```
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MapleFinanceTask {
        /// / The specific method to use for this task.
        #[prost(enumeration = "maple_finance_task::Method", optional, tag = "1")]
        pub method: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `MapleFinanceTask`.
    pub mod maple_finance_task {
        /// / Specifies the method to use for fetching Maple Finance data.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Method {
            /// / Fetch the fair price of syrupUSDC in the Maple Finance ecosystem.
            SyrupUsdcFairPrice = 0,
        }
        impl Method {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::SyrupUsdcFairPrice => "METHOD_SYRUP_USDC_FAIR_PRICE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "METHOD_SYRUP_USDC_FAIR_PRICE" => Some(Self::SyrupUsdcFairPrice),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GlyphTask {
        #[prost(string, optional, tag = "1")]
        pub pool_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "2")]
        pub zero_for_one: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CorexTask {
        #[prost(string, optional, tag = "1")]
        pub in_token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub out_token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(double, optional, tag = "3")]
        pub slippage: ::core::option::Option<f64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AftermathTask {
        #[prost(string, optional, tag = "1")]
        pub pool_address: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(double, optional, tag = "2")]
        pub in_amount: ::core::option::Option<f64>,
        #[prost(string, optional, tag = "3")]
        pub in_coin_type: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "4")]
        pub out_coin_type: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Interacts with a Large Language Model (LLM) to generate a text response based on a user-provided prompt.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: Text generated by the LLM based on the provided prompt and configuration.
    ///
    /// _**Example**_: Using OpenAI's GPT-4 model to generate a joke.
    ///
    /// ```json
    /// {
    /// "llmTask": {
    /// "providerConfig": {
    /// "openai": {
    /// "model": "gpt-4",
    /// "userPrompt": "Tell me a joke.",
    /// "temperature": 0.7,
    /// "secretNameApiKey": "${OPENAI_API_KEY}"
    /// }
    /// }
    /// }
    /// }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LlmTask {
        #[prost(oneof = "llm_task::ProviderConfig", tags = "1, 2, 3")]
        pub provider_config: ::core::option::Option<llm_task::ProviderConfig>,
    }
    /// Nested message and enum types in `LlmTask`.
    pub mod llm_task {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OpenAiConfig {
            #[prost(string, optional, tag = "1")]
            pub model: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "2")]
            pub user_prompt: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(double, optional, tag = "3")]
            pub temperature: ::core::option::Option<f64>,
            #[prost(string, optional, tag = "4")]
            pub secret_name_api_key: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GroqConfig {
            #[prost(string, optional, tag = "1")]
            pub model: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "2")]
            pub user_prompt: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(double, optional, tag = "3")]
            pub temperature: ::core::option::Option<f64>,
            #[prost(string, optional, tag = "4")]
            pub secret_name_api_key: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GrokXaiConfig {
            #[prost(string, optional, tag = "1")]
            pub model: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "2")]
            pub user_prompt: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(double, optional, tag = "3")]
            pub temperature: ::core::option::Option<f64>,
            #[prost(string, optional, tag = "4")]
            pub secret_name_api_key: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ProviderConfig {
            #[prost(message, tag = "1")]
            Openai(OpenAiConfig),
            #[prost(message, tag = "2")]
            Groq(GroqConfig),
            #[prost(message, tag = "3")]
            Grokxai(GrokXaiConfig),
        }
    }
    ///
    /// Fetch the current price of Solayer's sUSD stablecoin by reading its interest-bearing mint configuration.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The current price of sUSD relative to USD (1.0 = $1.00)
    ///
    /// _**Example**_: Fetch the current sUSD price
    ///
    /// ```json
    /// { "solayerSusdTask": {} }
    /// ```
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SolayerSusdTask {}
    ///
    /// Fetch pricing information from Curve Finance pools.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The current price/exchange rate from the specified Curve pool.
    ///
    /// _**Example**_: Fetch the price from a Curve pool on Ethereum
    ///
    /// ```json
    /// {
    /// "curveFinanceTask": {
    /// "chain": "CHAIN_ETHEREUM",
    /// "poolAddress": "0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7",
    /// "outDecimals": 18
    /// }
    /// }
    /// ```
    ///
    /// _**Example**_: Fetch the price using a custom RPC provider
    ///
    /// ```json
    /// {
    /// "curveFinanceTask": {
    /// "chain": "CHAIN_ETHEREUM",
    /// "provider": "<https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY",>
    /// "poolAddress": "0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7",
    /// "outDecimals": 18
    /// }
    /// }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CurveFinanceTask {
        /// / Required. Specifies which blockchain to use when reading information from Curve Finance.
        #[prost(enumeration = "curve_finance_task::Chain", optional, tag = "1")]
        pub chain: ::core::option::Option<i32>,
        /// / Optional. The RPC endpoint to use for blockchain requests. If not specified, a default RPC will be used which may have rate limits.
        #[prost(string, optional, tag = "2")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
        /// / The on-chain address of the Curve Finance pool to fetch pricing data from.
        #[prost(string, optional, tag = "3")]
        pub pool_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The number of decimal places to include in the returned price value.
        #[prost(uint32, optional, tag = "4")]
        pub out_decimals: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `CurveFinanceTask`.
    pub mod curve_finance_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Chain {
            /// / Use the Ethereum blockchain for fetching Curve Finance data
            Ethereum = 0,
        }
        impl Chain {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Ethereum => "CHAIN_ETHEREUM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CHAIN_ETHEREUM" => Some(Self::Ethereum),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Fetches tETH/WETH redemption rate
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TurboEthRedemptionRateTask {
        #[prost(string, optional, tag = "1")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Fetch the current swap price from a BitFlux pool.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The swap price between the specified input and output tokens.
    ///
    /// _**Example**_: Fetch the swap price using a custom RPC provider
    ///
    /// ```json
    /// {
    /// "bitFluxTask": {
    /// "provider": "<https://my-custom-rpc.example.com",>
    /// "poolAddress": "0x0000000000000000000000000000000000000000",
    /// "inToken": "0x0000000000000000000000000000000000000000",
    /// "outToken": "0x0000000000000000000000000000000000000000"
    /// }
    /// }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BitFluxTask {
        /// / Optional. The RPC endpoint to use for requests. If not specified, a default RPC will be used.
        #[prost(string, optional, tag = "1")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
        /// / The address of the BitFlux pool.
        #[prost(string, optional, tag = "2")]
        pub pool_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / The address of the input token.
        #[prost(string, optional, tag = "3")]
        pub in_token: ::core::option::Option<::prost::alloc::string::String>,
        /// / The address of the output token.
        #[prost(string, optional, tag = "4")]
        pub out_token: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Fetch the current price for Fragmetric liquid restaking tokens.
    ///
    /// _**Input**_: None
    ///
    /// _**Returns**_: The current price of the specified Fragmetric token relative to SOL (1.0 = 1 SOL)
    ///
    /// _**Example**_: Fetch the fragSOL token price
    ///
    /// ```json
    /// { "fragmetricTask": { "token": "TOKEN_FRAG_SOL" } }
    /// ```
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FragmetricTask {
        /// / The Fragmetric token to fetch the price for
        #[prost(enumeration = "fragmetric_task::Token", optional, tag = "1")]
        pub token: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `FragmetricTask`.
    pub mod fragmetric_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Token {
            /// / Fragmetric's liquid restaking token (fragSOL)
            FragSol = 0,
            /// / Fragmetric's native staking token (nSOL)
            NSol = 1,
        }
        impl Token {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::FragSol => "TOKEN_FRAG_SOL",
                    Self::NSol => "TOKEN_N_SOL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TOKEN_FRAG_SOL" => Some(Self::FragSol),
                    "TOKEN_N_SOL" => Some(Self::NSol),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EtherfuseTask {
        #[prost(enumeration = "etherfuse_task::Token", optional, tag = "1")]
        pub token: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `EtherfuseTask`.
    pub mod etherfuse_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Token {
            Cetes = 0,
            Ustry = 1,
            Eurob = 2,
            Tesouro = 3,
            Gilts = 4,
        }
        impl Token {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Cetes => "TOKEN_CETES",
                    Self::Ustry => "TOKEN_USTRY",
                    Self::Eurob => "TOKEN_EUROB",
                    Self::Tesouro => "TOKEN_TESOURO",
                    Self::Gilts => "TOKEN_GILTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TOKEN_CETES" => Some(Self::Cetes),
                    "TOKEN_USTRY" => Some(Self::Ustry),
                    "TOKEN_EUROB" => Some(Self::Eurob),
                    "TOKEN_TESOURO" => Some(Self::Tesouro),
                    "TOKEN_GILTS" => Some(Self::Gilts),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Query historical yield data for a given Liquid Staking Token (LST)
    /// and perform a statistical reduction operation over the dataset.
    ///
    /// _**Input**_: LST mint address, reduction operation type, and number of epochs to sample.
    ///
    /// _**Returns**_: The computed yield value based on the specified operation.
    ///
    /// _**Example**_: Compute the median APY for an LST over the last 100 epochs
    ///
    /// ```json
    /// {
    /// "lstHistoricalYieldTask": {
    /// "lstMint": "J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn",
    /// "operation": "OPERATION_MEDIAN",
    /// "epochs": 100
    /// }
    /// }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LstHistoricalYieldTask {
        /// / Required. The LST mint address for which historical yield data is queried.
        #[prost(string, optional, tag = "1")]
        pub lst_mint: ::core::option::Option<::prost::alloc::string::String>,
        /// / Required. The statistical operation to apply to the historical yield dataset.
        #[prost(
            enumeration = "lst_historical_yield_task::Operation",
            optional,
            tag = "2"
        )]
        pub operation: ::core::option::Option<i32>,
        /// / Optional. The number of epochs to sample for the computation.
        /// / - If `epochs = 0`, all available historical data will be used.
        /// / - If `epochs > 0`, only the last `epochs` entries will be included.
        #[prost(int32, optional, tag = "3")]
        pub epochs: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `LstHistoricalYieldTask`.
    pub mod lst_historical_yield_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operation {
            Median = 0,
            Mean = 1,
            Min = 2,
            Max = 3,
        }
        impl Operation {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Median => "OPERATION_MEDIAN",
                    Self::Mean => "OPERATION_MEAN",
                    Self::Min => "OPERATION_MIN",
                    Self::Max => "OPERATION_MAX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATION_MEDIAN" => Some(Self::Median),
                    "OPERATION_MEAN" => Some(Self::Mean),
                    "OPERATION_MIN" => Some(Self::Min),
                    "OPERATION_MAX" => Some(Self::Max),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Execute a swap task in the Pump AMM based on the given parameters.
    ///
    /// _**Input**_: Pool address, input token amount, max allowed slippage, and swap direction.
    ///
    /// _**Returns**_: Executes the swap operation in the Pump AMM with the given parameters.
    ///
    /// _**Example**_: Swap 10 tokens from X to Y with a maximum slippage of 0.5%
    ///
    /// ```json
    /// {
    /// "pumpAmmTask": {
    /// "pool_address": "Gf7sXMoP8iRw4iiXmJ1nq4vxcRycbGXy5RL8a8LnTd3v",
    /// "in_amount": "10",
    /// "max_slippage": 0.5,
    /// "is_x_for_y": true
    /// }
    /// }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PumpAmmTask {
        /// / Required. The address of the liquidity pool in the Pump AMM.
        #[prost(string, optional, tag = "1")]
        pub pool_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / Optional. The input token amount for the swap.
        /// / - This value should in full units of the input token.
        /// / - Default value: `1` (Swap 1 full token).
        #[prost(double, optional, tag = "2")]
        pub in_amount: ::core::option::Option<f64>,
        /// / Optional. The maximum allowed slippage for the swap, expressed as a percentage.
        /// / - Example: `0.5` represents 0.5% slippage tolerance.
        /// / - Default value: `3` (3% slippage tolerance).
        #[prost(double, optional, tag = "3")]
        pub max_slippage: ::core::option::Option<f64>,
        /// / Optional. Indicates the swap direction:
        /// / - `true`: Swapping token X for token Y.
        /// / - `false`: Swapping token Y for token X.
        /// / - Default value: `true`.
        #[prost(bool, optional, tag = "4")]
        pub is_x_for_y: ::core::option::Option<bool>,
    }
    ///
    /// Derive the fair LP token price for a given Pump AMM liquidity pool.
    ///
    /// _**Input**_: Pool address, X token price job, Y token price job.
    /// _**Returns**_: The fair LP token price for the given Pump AMM liquidity pool.
    /// _**Example**_: Derive the fair LP token price for a given Pump AMM liquidity pool.
    /// ```json
    /// {
    /// "pumpAmmLpTokenPriceTask": {
    /// "pool_address": "Gf7sXMoP8iRw4iiXmJ1nq4vxcRycbGXy5RL8a8LnTd3v", // USDC/SOL
    /// "x_price_job": {
    /// "oracleTask": {
    /// "switchboardAddress": "..." // USDC/USD
    /// }
    /// },
    /// "y_price_job": {
    /// "oracleTask": {
    /// "switchboardAddress": "..." // SOL/USD
    /// }
    /// }
    /// }
    /// }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PumpAmmLpTokenPriceTask {
        /// / Required. The address of the liquidity pool in the Pump AMM.
        #[prost(string, optional, tag = "1")]
        pub pool_address: ::core::option::Option<::prost::alloc::string::String>,
        /// / Required. The job to execute to fetch the price of the pool x token
        #[prost(message, optional, tag = "2")]
        pub x_price_job: ::core::option::Option<super::OracleJob>,
        /// / Required. The job to execute
        #[prost(message, optional, tag = "3")]
        pub y_price_job: ::core::option::Option<super::OracleJob>,
    }
    ///
    /// Get the exchange rate between and Exponent vault pricipal token and
    /// underlying token.
    /// _**Input**_: Vault address
    /// _**Returns**_: The exchange rate between the vault principal token and
    /// underlying token.
    /// _**Example**_: Get the exchange rate between the vault principal token and
    /// underlying token.
    /// ```json
    /// {
    /// "exponentTask": {
    /// "vault": "9YbaicMsXrtupkpD72pdWBfU6R7EJfSByw75sEpDM1uH"
    /// }
    /// }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExponentTask {
        #[prost(string, optional, tag = "1")]
        pub vault: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExponentPtLinearPricingTask {
        #[prost(string, optional, tag = "1")]
        pub vault: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(double, optional, tag = "2")]
        pub start_price: ::core::option::Option<f64>,
    }
    ///
    /// Apply Solana Token 2022 extension modifiers to a feed.
    /// _**Input**_: Token address and extension type.
    /// _**Returns**_: The value associated with the token2022 extension.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SolanaToken2022ExtensionTask {
        /// / The base58 encoded publicKey of the token mint address.
        #[prost(string, optional, tag = "1")]
        pub mint: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(
            enumeration = "solana_token2022_extension_task::Token2022Extension",
            optional,
            tag = "2"
        )]
        pub extension: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `SolanaToken2022ExtensionTask`.
    pub mod solana_token2022_extension_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Token2022Extension {
            Token2022ScaledAmountFactor = 0,
        }
        impl Token2022Extension {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Token2022ScaledAmountFactor => {
                        "TOKEN_2022_SCALED_AMOUNT_FACTOR"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TOKEN_2022_SCALED_AMOUNT_FACTOR" => {
                        Some(Self::Token2022ScaledAmountFactor)
                    }
                    _ => None,
                }
            }
        }
    }
    ///
    /// Fetch a *live* spot price straight out of the global **Surge** websocket
    /// cache  the same cache that powers our high-speed on-chain oracles.
    ///
    /// _**Input**_
    ///  `symbol`  the trading-pair symbol as it appears on the exchange
    ///  `source`  which exchange's stream to read from
    ///     `BINANCE`   (weight 3)
    ///     `BYBIT`     (weight 2)
    ///     `OKX`       (weight 2)
    ///     `COINBASE`  (weight 3, disabled)
    ///     `BITGET`    (weight 2)
    ///     `PYTH`      (weight 1)  Pyth oracle network
    ///     `TITAN`     (weight 1)  Titan DEX aggregator on Solana
    ///     `WEIGHTED`  (default)  use the *weighted median* of all
    ///      fresh quotes with the weights shown above.
    ///     `AUTO`       automatically select the best source based on
    ///      volume, spread, and data quality metrics.
    ///
    /// _**Returns**_
    /// The most recent price available from the chosen source.
    /// The task fails if the cached tick is older than **5 s**.
    ///
    /// _**Example**_: Pull the Binance price for BTC / USDT
    /// ```json
    /// {
    ///    "switchboardSurgeTask": {
    ///      "source": "BINANCE",
    ///      "symbol": "BTC/FDUSD"
    ///    }
    /// }
    /// ```
    ///
    /// _**Example**_: Use the weighted-median oracle for BTC / USDT
    /// ```json
    /// {
    ///    "switchboardSurgeTask": {
    ///      "source": "WEIGHTED",   // or omit  WEIGHTED is the default
    ///      "symbol": "BTC/USD"
    ///    }
    /// }
    /// ```
    ///
    /// _**Example**_: Pull the Pyth oracle price for PYUSD / USD
    /// ```json
    /// {
    ///    "switchboardSurgeTask": {
    ///      "source": "PYTH",
    ///      "symbol": "PYUSD/USD"
    ///    }
    /// }
    /// ```
    ///
    /// _**Example**_: Pull the Titan DEX aggregator price for SOL / USDC
    /// ```json
    /// {
    ///    "switchboardSurgeTask": {
    ///      "source": "TITAN",
    ///      "symbol": "SOL/USDC"
    ///    }
    /// }
    /// ```
    ///
    /// _**Notes**_
    ///  Symbols are auto-normalised (case-insensitive, punctuation removed).
    ///  If a venues price is stale (> 5 s) it is ignored in the WEIGHTED
    ///    calculation.  The task errors if **no** fresh price remains.
    ///  The weighted-median algorithm uses cumulative weights based on each
    ///    exchange's data quality and volume. Currently active sources:
    ///    Binance (3), Bybit (2), OKX (2), Bitget (2), Pyth (1), Titan (1).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SwitchboardSurgeTask {
        /// Determines which source will be used for pricing.
        /// Default: WEIGHTED average across all sources.
        #[prost(enumeration = "switchboard_surge_task::Source", optional, tag = "1")]
        pub source: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub symbol: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `SwitchboardSurgeTask`.
    pub mod switchboard_surge_task {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Source {
            /// DEPRECATED - backwards compatibility
            Weighted = 0,
            Binance = 1,
            Okx = 2,
            Bybit = 3,
            Coinbase = 4,
            Bitget = 5,
            Auto = 6,
            Pyth = 7,
            Titan = 8,
        }
        impl Source {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Weighted => "WEIGHTED",
                    Self::Binance => "BINANCE",
                    Self::Okx => "OKX",
                    Self::Bybit => "BYBIT",
                    Self::Coinbase => "COINBASE",
                    Self::Bitget => "BITGET",
                    Self::Auto => "AUTO",
                    Self::Pyth => "PYTH",
                    Self::Titan => "TITAN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "WEIGHTED" => Some(Self::Weighted),
                    "BINANCE" => Some(Self::Binance),
                    "OKX" => Some(Self::Okx),
                    "BYBIT" => Some(Self::Bybit),
                    "COINBASE" => Some(Self::Coinbase),
                    "BITGET" => Some(Self::Bitget),
                    "AUTO" => Some(Self::Auto),
                    "PYTH" => Some(Self::Pyth),
                    "TITAN" => Some(Self::Titan),
                    _ => None,
                }
            }
        }
    }
    ///
    /// Compute the BLAKE2b-128 hash of the input data and convert it to a numeric Decimal value.
    ///
    /// This task follows **cryptographic standard hash truncation** practices used in:
    /// - **SHA-224**: SHA-256 truncated to leftmost 224 bits
    /// - **BLAKE2s-128**: BLAKE2s-256 truncated to leftmost 128 bits
    /// - **BLAKE2b-256**: BLAKE2b-512 truncated to leftmost 256 bits
    ///
    /// _**Input**_: String data to hash (can be from a previous task's output)
    ///
    /// _**Returns**_: A positive Decimal number with 18 decimal places (scale 18)
    /// - Range: `0.000000000000000000` to `79228162514264.337593543950335` (2^96 - 1, scaled)
    /// - Example: `17512223723.299011049621773283`
    ///
    /// ---
    ///
    /// ## Hash-to-Decimal Conversion Algorithm
    ///
    /// ### Step-by-Step Process
    ///
    /// *1. Compute BLAKE2b-128 hash** (produces 16 bytes / 128 bits)
    /// ```
    /// Input:  "Hello, World!"
    /// Output: 3895c59e4aeb0903396b5be3fbec69fe
    /// ```
    ///
    /// *2. Truncate to 96 bits (12 bytes)** - keep the **most significant** bits
    /// ```
    /// KEPT (first 12 bytes):      3895c59e4aeb0903396b5be3
    /// DISCARDED (last 4 bytes):   fbec69fe
    /// ```
    /// This follows cryptographic standards where truncation keeps the leftmost/most significant bits.
    ///
    /// *3. Pad to 16 bytes** for u128 representation
    /// ```
    /// Add 4 zero bytes at the BEGINNING:
    ///
    /// 000000003895c59e4aeb0903396b5be3
    /// 
    /// padding      first 12 bytes
    /// (4 bytes)    (most significant)
    /// ```
    ///
    /// *4. Interpret as u128 using big-endian** byte order
    /// ```
    /// Hex:     0x000000003895c59e4aeb0903396b5be3
    /// Decimal: 17512223723299011049621773283
    /// ```
    /// Big-endian is the standard for cryptographic hash representations.
    ///
    /// *5. Convert to Decimal** with scale 18 (18 decimal places)
    /// ```
    /// Value:  17512223723299011049621773283
    /// Scaled: 17512223723.299011049621773283 (divided by 10^18)
    /// ```
    /// Scale 18 prevents precision loss when the protocol rescales values.
    /// Guaranteed to fit in Decimal's 96-bit mantissa (max: 2^96 - 1).
    ///
    /// ---
    ///
    /// ## Reproducibility
    ///
    /// To reproduce this conversion in **any programming language**:
    ///
    /// ### Python Example
    /// ```python
    /// import hashlib
    /// from decimal import Decimal
    ///
    /// # 1. Compute BLAKE2b-128 hash
    /// data = b"Hello, World!"
    /// hash_bytes = hashlib.blake2b(data, digest_size=16).digest()
    /// # Result: b'\x38\x95\xc5\x9e\x4a\xeb\x09\x03\x39\x6b\x5b\xe3\xfb\xec\x69\xfe'
    ///
    /// # 2. Keep first 12 bytes (most significant 96 bits)
    /// truncated = hash_bytes\[:12\]
    ///
    /// # 3. Pad with 4 zero bytes at the beginning
    /// padded = b'\x00\x00\x00\x00' + truncated
    ///
    /// # 4. Interpret as u128 big-endian
    /// value = int.from_bytes(padded, byteorder='big')
    /// # Result: 17512223723299011049621773283
    ///
    /// # 5. Apply scale 18 (divide by 10^18)
    /// result = Decimal(value) / Decimal(10**18)
    /// # Result: Decimal('17512223723.299011049621773283')
    /// ```
    ///
    /// ### JavaScript Example
    /// ```javascript
    /// const crypto = require('crypto');
    ///
    /// // 1. Compute BLAKE2b-128 hash
    /// const hash = crypto.createHash('blake2b512')
    /// .update('Hello, World!')
    /// .digest()
    /// .slice(0, 16); // Take first 16 bytes for BLAKE2b-128
    ///
    /// // 2. Keep first 12 bytes
    /// const truncated = hash.slice(0, 12);
    ///
    /// // 3. Pad with 4 zero bytes at the beginning
    /// const padded = Buffer.concat(\[Buffer.alloc(4), truncated\]);
    ///
    /// // 4. Interpret as big-endian u128
    /// let value = 0n;
    /// for (let i = 0; i < 16; i++) {
    /// value = (value << 8n) | BigInt(padded\[i\]);
    /// }
    /// // Result: 17512223723299011049621773283n
    ///
    /// // 5. Apply scale 18 (divide by 10^18)
    /// const result = Number(value) / 1e18;
    /// // Result: 17512223723.299011 (note: JS loses precision beyond ~15 digits)
    /// ```
    ///
    /// ### Rust Example
    /// ```rust
    /// use blake2::{Blake2b, Digest};
    /// use blake2::digest::consts::U16;
    /// use rust_decimal::Decimal;
    ///
    /// type Blake2b128 = Blake2b<U16>;
    ///
    /// // 1. Compute BLAKE2b-128 hash
    /// let mut hasher = Blake2b128::new();
    /// hasher.update(b"Hello, World!");
    /// let hash = hasher.finalize();
    ///
    /// // 2. Keep first 12 bytes and pad at beginning
    /// let mut bytes = \[0u8; 16\];
    /// bytes\[4..16\].copy_from_slice(&hash\[0..12\]);
    ///
    /// // 3. Interpret as big-endian u128
    /// let value = u128::from_be_bytes(bytes);
    /// // Result: 17512223723299011049621773283
    ///
    /// // 4. Apply scale 18 (convert with 18 decimal places)
    /// let result = Decimal::from_i128_with_scale(value as i128, 18);
    /// // Result: Decimal("17512223723.299011049621773283")
    /// ```
    ///
    /// ---
    ///
    /// ## Why This Approach?
    ///
    ///  **Cryptographic Standard**: Follows the same truncation method as SHA-224, BLAKE2s-128, etc.
    ///  **Preserves Entropy**: Keeps the most significant/diverse bits of the hash
    ///  **Big-Endian**: Standard convention for cryptographic hash representations
    ///  **Fits Decimal Range**: 96 bits always fits within Decimal's mantissa (max 2^96-1)
    ///  **Scale 18**: Prevents precision loss when protocol rescales values
    ///  **Reproducible**: Simple algorithm implementable in any programming language
    ///  **Deterministic**: Same input always produces same output
    ///
    /// ---
    ///
    /// _**Example**_: Hash a static string
    ///
    /// ```json
    /// {
    /// "blake2b128Task": {
    /// "value": "Hello, World!"
    /// }
    /// }
    /// ```
    ///
    /// _**Example**_: Hash the output from a previous task (e.g., HTTP response)
    ///
    /// ```json
    /// {
    /// "tasks": [
    /// {
    /// "httpTask": {
    /// "url": "<https://example.com/data">
    /// }
    /// },
    /// {
    /// "blake2b128Task": {}
    /// }
    /// ]
    /// }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Blake2b128Task {
        /// / Optional value to hash. If not provided or empty, will use the previous task output.
        #[prost(string, optional, tag = "1")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
    ///
    /// Map a string input to a predefined output value using exact string matching.
    ///
    /// _**Input**_: String from previous task output or specified value
    ///
    /// _**Returns**_: The mapped value as a string if a match is found, or the default value if no match is found.
    ///
    /// _**Example**_: Map "yes" to "1", "no" to "2", "maybe" to "3" (case-insensitive)
    ///
    /// ```json
    /// {
    /// "stringMapTask": {
    /// "mappings": [
    /// {"key": "yes", "value": "1"},
    /// {"key": "no", "value": "2"},
    /// {"key": "maybe", "value": "3"}
    /// ],
    /// "defaultValue": "0",
    /// "caseSensitive": false
    /// }
    /// }
    /// ```
    ///
    /// _**Example**_: Map HTTP response status with case-sensitive matching
    ///
    /// ```json
    /// {
    /// "tasks": [
    /// {
    /// "httpTask": {
    /// "url": "<https://api.example.com/status">
    /// }
    /// },
    /// {
    /// "regexExtractTask": {
    /// "pattern": "status\":\\s*\"(\[^\"\]+)\""
    /// }
    /// },
    /// {
    /// "stringMapTask": {
    /// "mappings": [
    /// {"key": "active", "value": "100"},
    /// {"key": "inactive", "value": "0"},
    /// {"key": "pending", "value": "50"}
    /// ],
    /// "defaultValue": "-1",
    /// "caseSensitive": true
    /// }
    /// }
    /// ]
    /// }
    /// ```
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringMapTask {
        /// / The list of key-value mappings.
        #[prost(message, repeated, tag = "1")]
        pub mappings: ::prost::alloc::vec::Vec<string_map_task::Mapping>,
        /// / Optional default value to return if no mapping matches. If not provided and no match is found, the task will fail.
        #[prost(string, optional, tag = "2")]
        pub default_value: ::core::option::Option<::prost::alloc::string::String>,
        /// / Whether the string matching should be case-sensitive. Defaults to true.
        #[prost(bool, optional, tag = "3", default = "true")]
        pub case_sensitive: ::core::option::Option<bool>,
        /// / Optional input value to map. If not provided, will use the previous task output.
        #[prost(string, optional, tag = "4")]
        pub input: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `StringMapTask`.
    pub mod string_map_task {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Mapping {
            /// / The string key to match against.
            #[prost(string, optional, tag = "1")]
            pub key: ::core::option::Option<::prost::alloc::string::String>,
            /// / The value to return if the key matches.
            #[prost(string, optional, tag = "2")]
            pub value: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
    /// / Represents a singular operation performed by an oracle to yield an eventual numerical result.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Task {
        #[prost(
            oneof = "task::Task",
            tags = "1, 2, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 71, 20, 21, 23, 24, 25, 26, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 56, 57, 58, 59, 60, 61, 63, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76"
        )]
        pub task: ::core::option::Option<task::Task>,
    }
    /// Nested message and enum types in `Task`.
    pub mod task {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Task {
            #[prost(message, tag = "1")]
            HttpTask(super::HttpTask),
            #[prost(message, tag = "2")]
            JsonParseTask(super::JsonParseTask),
            #[prost(message, tag = "4")]
            MedianTask(super::MedianTask),
            #[prost(message, tag = "5")]
            MeanTask(super::MeanTask),
            #[prost(message, tag = "7")]
            DivideTask(super::DivideTask),
            #[prost(message, tag = "8")]
            MultiplyTask(super::MultiplyTask),
            #[prost(message, tag = "9")]
            LpTokenPriceTask(super::LpTokenPriceTask),
            #[prost(message, tag = "10")]
            LpExchangeRateTask(super::LpExchangeRateTask),
            #[prost(message, tag = "11")]
            ConditionalTask(super::ConditionalTask),
            #[prost(message, tag = "12")]
            ValueTask(super::ValueTask),
            #[prost(message, tag = "13")]
            MaxTask(super::MaxTask),
            #[prost(message, tag = "14")]
            RegexExtractTask(super::RegexExtractTask),
            #[prost(message, tag = "15")]
            XstepPriceTask(super::XStepPriceTask),
            #[prost(message, tag = "16")]
            AddTask(super::AddTask),
            #[prost(message, tag = "17")]
            SubtractTask(super::SubtractTask),
            #[prost(message, tag = "19")]
            SerumSwapTask(super::SerumSwapTask),
            #[prost(message, tag = "71")]
            OpenbookTask(super::SerumSwapTask),
            #[prost(message, tag = "20")]
            PowTask(super::PowTask),
            #[prost(message, tag = "21")]
            LendingRateTask(super::LendingRateTask),
            #[prost(message, tag = "23")]
            JupiterSwapTask(super::JupiterSwapTask),
            #[prost(message, tag = "24")]
            PerpMarketTask(super::PerpMarketTask),
            #[prost(message, tag = "25")]
            OracleTask(super::OracleTask),
            #[prost(message, tag = "26")]
            AnchorFetchTask(super::AnchorFetchTask),
            #[prost(message, tag = "29")]
            SplStakePoolTask(super::SplStakePoolTask),
            #[prost(message, tag = "30")]
            SplTokenParseTask(super::SplTokenParseTask),
            #[prost(message, tag = "31")]
            UniswapExchangeRateTask(super::UniswapExchangeRateTask),
            #[prost(message, tag = "32")]
            SushiswapExchangeRateTask(super::SushiswapExchangeRateTask),
            #[prost(message, tag = "33")]
            PancakeswapExchangeRateTask(super::PancakeswapExchangeRateTask),
            #[prost(message, tag = "34")]
            CacheTask(super::CacheTask),
            #[prost(message, tag = "35")]
            SysclockOffsetTask(super::SysclockOffsetTask),
            #[prost(message, tag = "36")]
            MarinadeStateTask(super::MarinadeStateTask),
            #[prost(message, tag = "37")]
            SolanaAccountDataFetchTask(super::SolanaAccountDataFetchTask),
            #[prost(message, tag = "38")]
            BufferLayoutParseTask(super::BufferLayoutParseTask),
            #[prost(message, tag = "39")]
            CronParseTask(super::CronParseTask),
            #[prost(message, tag = "40")]
            MinTask(super::MinTask),
            #[prost(message, tag = "44")]
            ComparisonTask(super::ComparisonTask),
            #[prost(message, tag = "45")]
            RoundTask(super::RoundTask),
            #[prost(message, tag = "46")]
            BoundTask(super::BoundTask),
            #[prost(message, tag = "47")]
            SecretsTask(super::SecretsTask),
            #[prost(message, tag = "48")]
            SanctumLstPriceTask(super::SanctumLstPriceTask),
            #[prost(message, tag = "49")]
            OndoUsdyTask(super::OndoUsdyTask),
            #[prost(message, tag = "50")]
            MeteoraSwapTask(super::MeteoraSwapTask),
            #[prost(message, tag = "51")]
            UnixTimeTask(super::UnixTimeTask),
            #[prost(message, tag = "52")]
            MapleFinanceTask(super::MapleFinanceTask),
            #[prost(message, tag = "53")]
            GlyphTask(super::GlyphTask),
            #[prost(message, tag = "54")]
            CorexTask(super::CorexTask),
            #[prost(message, tag = "56")]
            SolayerSusdTask(super::SolayerSusdTask),
            #[prost(message, tag = "57")]
            CurveFinanceTask(super::CurveFinanceTask),
            #[prost(message, tag = "58")]
            TurboEthRedemptionRateTask(super::TurboEthRedemptionRateTask),
            #[prost(message, tag = "59")]
            BitFluxTask(super::BitFluxTask),
            #[prost(message, tag = "60")]
            FragmetricTask(super::FragmetricTask),
            #[prost(message, tag = "61")]
            AftermathTask(super::AftermathTask),
            #[prost(message, tag = "63")]
            EtherfuseTask(super::EtherfuseTask),
            #[prost(message, tag = "64")]
            LstHistoricalYieldTask(super::LstHistoricalYieldTask),
            #[prost(message, tag = "65")]
            PumpAmmTask(super::PumpAmmTask),
            #[prost(message, tag = "66")]
            PumpAmmLpTokenPriceTask(super::PumpAmmLpTokenPriceTask),
            #[prost(message, tag = "67")]
            ExponentTask(super::ExponentTask),
            #[prost(message, tag = "68")]
            ExponentPtLinearPricingTask(super::ExponentPtLinearPricingTask),
            #[prost(message, tag = "69")]
            SolanaToken2022ExtensionTask(super::SolanaToken2022ExtensionTask),
            #[prost(message, tag = "70")]
            SwitchboardSurgeTask(super::SwitchboardSurgeTask),
            #[prost(message, tag = "72")]
            KalshiApiTask(super::KalshiApiTask),
            #[prost(message, tag = "73")]
            TitanTask(super::TitanTask),
            #[prost(message, tag = "74")]
            Blake2b128Task(super::Blake2b128Task),
            #[prost(message, tag = "75")]
            HyloTask(super::HyloTask),
            #[prost(message, tag = "76")]
            StringMapTask(super::StringMapTask),
        }
    }
}
